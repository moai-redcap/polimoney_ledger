import 'package:supabase_flutter/supabase_flutter.dart';
import '../../domain/models/journal.dart';
import '../../domain/models/journal_entry.dart';

class JournalRepository {
  final SupabaseClient _supabase;

  JournalRepository(this._supabase);

  Future<List<Journal>> fetchJournals({
    String? organizationId,
    String? electionId,
  }) async {
    assert(organizationId != null || electionId != null);

    var query = _supabase.from('journals').select();

    if (organizationId != null) {
      query = query.eq('organization_id', organizationId);
    } else if (electionId != null) {
      query = query.eq('election_id', electionId);
    }

    final response = await query.order('journal_date', ascending: false);
    return (response as List).map((json) => Journal.fromJson(json)).toList();
  }

  Future<List<JournalEntry>> fetchJournalEntries(String journalId) async {
    final response = await _supabase
        .from('journal_entries')
        .select()
        .eq('journal_id', journalId);

    return (response as List)
        .map((json) => JournalEntry.fromJson(json))
        .toList();
  }

  Future<void> createJournal({
    required Journal journal,
    required List<JournalEntry> entries,
  }) async {
    // Using a simple approach since Supabase Flutter doesn't support transactions directly in the client SDK easily without RPC.
    // However, we can try to chain them or use RPC if strict atomicity is required.
    // For now, we will insert Journal first, then Entries.
    // TODO: Consider using an RPC for atomic transaction.

    final journalData = journal.toJson();
    journalData.remove(
      'id',
    ); // Let DB generate ID if not provided, or use the one provided if we generated it locally.
    // Actually, the model has ID required. Let's assume we generate UUIDs locally or let DB handle it.
    // If we let DB handle it, we shouldn't send 'id' if it's empty or placeholder.
    // But our model `toJson` includes `id`.
    // Let's assume we use `uuid` package to generate IDs on client side for consistency, or we omit ID and let DB generate, then get it back.
    // The `Journal` model constructor requires `id`.
    // Let's assume the `id` in `journal` object is valid (generated by uuid v4).

    await _supabase.from('journals').insert({
      'organization_id': journal.organizationId,
      'election_id': journal.electionId,
      'journal_date': journal.journalDate.toIso8601String(),
      'description': journal.description,
      'status': journal.status,
      'submitted_by_user_id': journal.submittedByUserId,
      'approved_by_user_id': journal.approvedByUserId,
      'contact_id': journal.contactId,
      'classification': journal.classification,
      'non_monetary_basis': journal.nonMonetaryBasis,
      'notes': journal.notes,
      'amount_political_grant': journal.amountPoliticalGrant,
      'amount_political_fund': journal.amountPoliticalFund,
      'is_receipt_hard_to_collect': journal.isReceiptHardToCollect,
      'receipt_hard_to_collect_reason': journal.receiptHardToCollectReason,
    });

    // We need the journal ID for entries.
    // If we didn't generate ID client-side, we would need to fetch it.
    // But let's assume we fetch the inserted journal to get the ID if we didn't provide it.
    // Wait, the `createJournal` method receives a `Journal` object which has an `id`.
    // If that ID is just a placeholder, we have a problem.
    // Better pattern: return the created Journal.

    // Let's change the approach:
    // 1. Insert Journal and select single to get ID.
    // 2. Insert Entries using that ID.

    // But wait, the `journal` argument already has an ID?
    // If the caller generated it, we can use it.
    // Let's assume the caller might not have generated a valid UUID if they expect the DB to do it.
    // But `Journal` model requires `id`.
    // Let's assume the caller uses `const Uuid().v4()` to generate ID before calling this.
    // However, to be safe and follow the previous repository pattern:

    /*
    final journalResponse = await _supabase.from('journals').insert(journalDataWithoutId).select().single();
    final newJournalId = journalResponse['id'];
    */

    // But `entries` need `journal_id`.
    // So we should do:

    final journalInsertData = {
      'organization_id': journal.organizationId,
      'election_id': journal.electionId,
      'journal_date': journal.journalDate.toIso8601String(),
      'description': journal.description,
      'status': journal.status,
      'submitted_by_user_id': journal.submittedByUserId,
      'approved_by_user_id': journal.approvedByUserId,
      'contact_id': journal.contactId,
      'classification': journal.classification,
      'non_monetary_basis': journal.nonMonetaryBasis,
      'notes': journal.notes,
      'amount_political_grant': journal.amountPoliticalGrant,
      'amount_political_fund': journal.amountPoliticalFund,
      'is_receipt_hard_to_collect': journal.isReceiptHardToCollect,
      'receipt_hard_to_collect_reason': journal.receiptHardToCollectReason,
    };

    final journalResponse = await _supabase
        .from('journals')
        .insert(journalInsertData)
        .select()
        .single();

    final newJournalId = journalResponse['id'] as String;

    final entriesData = entries
        .map(
          (e) => {
            'journal_id': newJournalId,
            'account_code': e.accountCode,
            'sub_account_id': e.subAccountId,
            'debit_amount': e.debitAmount,
            'credit_amount': e.creditAmount,
          },
        )
        .toList();

    await _supabase.from('journal_entries').insert(entriesData);
  }

  Future<void> updateJournalStatus(
    String journalId,
    String status,
    String? approvedByUserId,
  ) async {
    await _supabase
        .from('journals')
        .update({'status': status, 'approved_by_user_id': approvedByUserId})
        .eq('id', journalId);
  }

  Future<void> deleteJournal(String journalId) async {
    await _supabase.from('journals').delete().eq('id', journalId);
  }
}
